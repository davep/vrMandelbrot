<html>

  <head>

    <title>Simple VR Mandelbrot</title>

    <style>
     body {
         margin: 0;
     }
    </style>

  </head>

  <body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.min.js" integrity="sha512-OZ6CXzl5JrSc9OM1lxp1OC+zt5gCTVAqy7nWwbdSUE98akAvGl/20WaIqsRUnSpBG+QBkcMkiJVfFvybZ6PtKQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script type="module">

     // Import the framework.
     import * as THREE from "https://unpkg.com/three@0.127.0/build/three.module.js";
     import { VRButton } from "https://unpkg.com/three@0.127.0/examples/jsm/webxr/VRButton.js";
     import { BoxLineGeometry } from "https://unpkg.com/three@0.127.0/examples/jsm/geometries/BoxLineGeometry.js";
     import { XRControllerModelFactory } from "https://unpkg.com/three@0.127.0/examples/jsm/webxr/XRControllerModelFactory.js";

     // Constants
     const PIXEL_SIZE  = 0.1;
     const CANVAS_SIZE = 3;
     const GAP_SIZE    = 0.005;
     const PIXEL_SHAPE = new THREE.BoxGeometry( PIXEL_SIZE - GAP_SIZE, PIXEL_SIZE - GAP_SIZE, PIXEL_SIZE - GAP_SIZE );
     const CANVAS      = Array.from( Array( ( CANVAS_SIZE / PIXEL_SIZE ) * 2 ), () => new Array( ( CANVAS_SIZE / PIXEL_SIZE ) * 2 ) );
     const RESOLUTION  = 20;

     // Add some light to the scene.
     function theLight( scene ) {

         // First off, add some ambient light to lift everything.
         scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.2 ) );

         // Next, add a directional light to give a little bit of contrast
         // to different surfaces.
         const light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
         light.position.set( 0, 10, 0 );
         light.target.position.set( -5, 0, 0 );
         scene.add( light );
         scene.add( light.target );
     }

     // Function for making the camrea.
     function theCamera() {
         const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
         camera.position.z = 5;
         return camera
     }

     // Add a controller to the scene.
     function addController( renderer, scene, id ) {
         const controller = renderer.xr.getController( id );
         scene.add( controller );

         const controllerModelFactory = new XRControllerModelFactory();

         const controllerGrip = renderer.xr.getControllerGrip( id );
         controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
         scene.add( controllerGrip );
     }

     // Oh hi Mark!
     function theRoom() {
         return new THREE.LineSegments(
             new BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 3, 0 ),
             new THREE.LineBasicMaterial( { color: 0xFFFF00 } )
         );
     }

     // Function for making the renderer.
     function theRenderer() {
         const renderer = new THREE.WebGLRenderer();
         renderer.setSize( window.innerWidth, window.innerHeight );
         renderer.xr.enabled = true;
         document.body.appendChild( renderer.domElement );
         return renderer
     }

     // Function for making a pixel.
     function thePixel( xOffset, yOffset ) {
         const pixel = new THREE.Mesh( PIXEL_SHAPE, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
         pixel.position.x = xOffset;
         pixel.position.y = yOffset + CANVAS_SIZE;
         pixel.position.z = -1;
         return pixel;
     }

     // Create the things that will help make the scene.
     const scene = new THREE.Scene();
     const camera = theCamera();
     const renderer = theRenderer()

     // Add the conteollers.
     addController( renderer, scene, 0 );
     addController( renderer, scene, 1 );

     // Add some light to the scene.
     theLight( scene );

     // Create a room to stand in.
     const room = theRoom();
     scene.add( room );

     // Some crappy mapping.
     const canvasPos = n => Math.trunc( ( n / PIXEL_SIZE ) + ( CANVAS_SIZE / PIXEL_SIZE ) );

     // Add some cubes to the room.
     for ( let x = -CANVAS_SIZE; x <= CANVAS_SIZE; x += PIXEL_SIZE ) {
         for ( let y = -CANVAS_SIZE; y <= CANVAS_SIZE; y += PIXEL_SIZE ) {
             CANVAS[ canvasPos( x ) ][ canvasPos( y ) ] = {
                 step: RESOLUTION,
                 pos: math.complex( 0, 0 ),
                 start: math.complex( x, y ),
                 pixel: thePixel( x, y )
             };
             room.add( CANVAS[ canvasPos( x ) ][ canvasPos( y ) ].pixel );
         }
     }

     // Add the button that lets people switch into VR.
     document.body.appendChild( VRButton.createButton( renderer ) );

     // Tracking variables for the render loop.
     let x = -CANVAS_SIZE;
     let y = -CANVAS_SIZE;

     // Update a single spot on the canvas.
     function update( spot ) {
         if ( spot.step > 0 ) {
             if ( spot.pos.abs() > 2.0 ) {
                 room.remove( spot.pixel );
                 spot.step = 0;
             } else {
                 spot.pos = spot.start.add( spot.pos.mul( spot.pos ) );
                 spot.step -= 1;
             }
         }
     }

     // animation loop.
     renderer.setAnimationLoop( () => {

         // Update the current spot. Note that, on purpose, this is taking a
         // *very* slow walk through the canvas and calculating the set.
         // This isn't supposed to be efficiant. It's supposed to be the
         // opposite. It's mostly about playign with drawing in VR space.
         update( CANVAS[ canvasPos( x ) ][ canvasPos( y ) ] );

         // Move along...
         x += PIXEL_SIZE;
         if ( x >= CANVAS_SIZE ) {
             x = -CANVAS_SIZE;
             y += PIXEL_SIZE;
         }
         if ( y >= CANVAS_SIZE ) {
             y = -CANVAS_SIZE;
         }

         renderer.render( scene, camera );
     } );

    </script>

  </body>

</html>

<!-- index.html ends here -->
